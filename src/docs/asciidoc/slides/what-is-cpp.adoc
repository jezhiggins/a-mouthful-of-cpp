== {cpp}

What is C++?

[NOTE.speaker]
--
What, then, is C++?

That's a pretty open ended question, so instead I'd like to start with ...

What do you think C++ is?
--

== {cpp}

What do you think C++ is?

[NOTE.speaker]
--
Or, perhaps, what do you think of C++?

All languages have a degree of rumour and hearsay around them - often of the form "nobody uses that anymore", "it's really complicated" (eg Perl, Ruby, XSLT, Cobol) - and less commonly, "the people who use are all snobs and weirdos" (Lisp, Haskell, C++).

But what do you think C++ is? What's it's used for, or what you've heard about working in it or anything like that.

I'm not trying to catch anyone out here - I'm not going to leap on what you say and tear it to bits. You might, after all, think people who use it are snobs and weirdos, and nothing could be worse than if I immediately proved that to be the case :)


--

== {cpp}

What do you think C++ is?

What would you like to know?

[NOTE.speaker]
--
All languages have a degree of rumour and hearsay around them - often of the form "nobody uses that anymore", "it's really complicated" (eg Perl, Ruby, XSLT, Cobol) - and less commonly, "the people who use are all snobs and weirdos" (Lisp, Haskell, C++).

But what do you think C++ is? What's it's used for, or what you've heard about working in it or anything like that.

I'm not trying to catch anyone out here - I'm not going to leap on what you say and tear it to bits. You might, after all, think people who use it are snobs and weirdos, and nothing could be worse than if I immediately proved that to be the case :)

We can also turn this around. I appreciate this is might be a difficult question, but what would you to know about C++? I might not be able to tell you, but if you have a question do ask, either now or as they occur to you. This whole thing will be better if you do. I'm a decent hand at {cpp}, but one of the ways we learn is by teaching. There are, hopefully, things I can show you this afternoon, and there are definitely things you can teach me. If there's something that's not clear, or it sounds like I'm just talking nonsense, or, you know, you're just interested then please do ask and by the end of the afternoon we'll all come out with a better appreciation of the language than when we came in.

While I was preparing for this session, I spoke to a number of different people about what they might want to get out of a session like this.
--

=== !

[quote]
--
I would hope to gain the dissolution of fear.
--
=== !

[quote]
--
I see C++ and the like as developers that just have a completely different mindset and skill because it feels like less is done for them. How do you do it?
--

=== !

[quote]
--
I'm not your audience because I jumped OOP
--

=== !

[quote]
--
Why?
--

== {cpp}

{cpp} is a general purpose programming language

[NOTE.speaker]
--
This is a pretty high-level statement right?

General is pretty vague, right? "Well, you can just use it for, you know, stuff". We can think of languages which aren't general - SQL, for instance, or XSLT which are really quite narrowly focussed. We can think about something like R or MATLAB which are particularly aimed at numerical analysis. That's wider than, say, the query focus of SQL, but it's not "general", general.

For C++, when we talk about general purpose, we mean from the operating system up - that you can write any part of you software from the very lowest level right up to the user interface on the front, whether that user interface is a desktop application, a web browser, or a couple of seven segment displays and a couple of LEDs on your washing machine.

You might also hear this called "systems programming".

To span that range of, I was going to say applications, different uses, what do you think you want for, need in, a language?

Languages in a similar space - Rust, Go, Ada, D, C.
--

== {cpp}

* it is multi-paradigm

* compiled

* statically typed

[NOTE.speaker]
--
More specifically, C++ is a general purpose programming language which is multi-paradigm, compiled, strongly and statically typed.

Is everyone comfortable with what those things mean.
--

=== Multi-paradigm

[quote, Bjarne Stroustrup]
--
Multiparadigm programming is a fancy way of saying "`programming using more than one programming style, each to its best effect.`"

We need a better -- more descriptive -- term to replace "`multi-paradigm`".
--

[NOTE.speaker]
--
He continues "For example, using object-oriented programming when run-time resolution between different object types is required and generic programming when static type safety and run-time performance is at a premium. Naturally, the main strength of multiparadigm programming is in programs where more than one paradigm (programming style) is used, so that it would be hard to get the same effect by composing a system out of parts written in languages supporting different paradigms. I find the most compelling cases for multiparadigm programming are found where techniques from different paradigms are used in close collaboration to write code that is more elegant and more maintainable than would be possible within a single paradigm."
--

=== Multi-paradigm

image::multi-paradigm-design-for-cpp.jpg['Multi-Paradigm Design for C++']

[NOTE.speaker]
--
Nearly all programming languages are, to some extent, multi-paradigm - they don't force you to program in one particular way. However, some languages certainly give a pretty strong steer in a particular direction. It would not, for instance, be controversial to say "Java *is* an object-oriented programming language" or that "Lisp *is* a function programming language". (There are lots of arguments about what Lisp is, but that isn't one of them.) C++ has always rejected that and aimed to be a general purpose language, and being general purporse you have to support the code that people want to write.

C++ provides language or standard library support for procedural programming, object-oriented programming, generic programming, compile-time meta-programming, there's support common for contracts, and there's decent language and library support for concurrent programming.

But don't take my word for it ... he's Jim Coplien's 1999 book on it. The word design is all-capped because his contention was that C++ offered you this array of programming styles, but people generally picked one and went with that. In 1999 that would almost certainly have been OO. He advanced the idea that most problems don't fall neatly into one category like that, and so you need to draw on all the tools available to you. I'm probably horribly over simplifying, so I'd be grateful if no one repeats what I've just said to Cope, because he frightens me :)
--

=== Compiled

[ditaa, "compile", "svg"]
--

 +--------------+                                +--------------+                                /--------------\
 |              |        +--------------+        |              |        +--------------+        |              |
 |              |        |              |        |              |        |              |        |              |
 |              |        |              |        |              |        |              |        |              |
 |    Source    |  --->  |   Compiler   |  --->  |    Object    |  --->  |    Linker    |  --->  |   Program    |
 |     code     |        |              |        |     file     |        |              |        |              |
 |              |        |              |        |              |        |              |        |              |
 |           {d}|        +--------------+        |           {d}|        +--------------+        |              |
 +--------------+                                +--------------+                                \--------------/
                                                                                 ^
                                                                                 |
                                                                                 |

                                                                         +--------------+
                                                                         |              |
                                                                         |  Libraries   |
                                                                         |           {d}|
                                                                         +--------------+
--

[NOTE.speaker]
--

Compiled - to machine code!

Perl, Ruby, Python, JavaScript - just run them! Source is portable.

(Ok, we have some kind of bundling stage with JavaScript, but it's not compilation. Python spits out .pyc files of its byte code, but you don't distribute those and you could go your whole life without ever seeing them. This is not the case here.)

Java, C# - compiled to byte code, run that on a JVM. Bytecode is portable. (Might hotspot compiled to machine code on the fly, but that isn't part of the delivered executable.)

C++, Go, Rust - compiled to machine code.  Source can be portable, executables are not.
--
=== Statically Typed

Constants and variables have a type, and that type doesn't change

The type of a variable is known at creation time.

[NOTE.speaker]
--

--

=== Statically Typed

[source,javascript]
--

--
